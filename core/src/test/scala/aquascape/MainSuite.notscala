/*
 * Copyright 2023 Zainab Ali
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aquascape

import fs2.*
import cats.effect.*
import aquascape.Trace
import munit.CatsEffectSuite
import munit.Location

class MainSuite extends CatsEffectSuite {
  object Boom extends Throwable("BOOM!")

  import Event.*

  def step(labels: List[String], e: Event)(using
      loc: munit.Location
  ): (Step, Location) =
    Step(labels, e) -> loc

  def reify(steps: List[Step]): String = {
    def reify(step: Step): String =
      def reify(label: String): String = s""""$label""""
      def reifyE(event: Event): String = event match {
        case Eval(v)        => s"Eval(${reify(v)})"
        case Error(v)       => s"Error(${reify(v)})"
        case Output(v)      => s"Output(${reify(v)})"
        case OutputChunk(v) => s"OutputChunk(${v.map(reify)})"
        case OpenScope(v)   => s"OpenScope(${reify(v)})"
        case CloseScope(v)  => s"CloseScope(${reify(v)})"
        case o              => o.toString

      }
      s"""step(${step.labels.map(reify)}, ${reifyE(step.e)})  """
    steps.map(reify).toString
    pprint(steps).plainText
  }
  def assertSteps(actualIO: IO[List[Step]], expected: List[(Step, Location)])(
      using loc: munit.Location
  ): IO[Unit] = {
    actualIO.map { actual =>
      actual.zipWithIndex.zip(expected).map { case ((a, i), (e, l)) =>
        assertEquals(a, e, s"Step $i is incorrect - ${reify(actual)}")(
          l,
          summon[Step <:< Step]
        )
      }
      assertEquals(
        actual.length,
        expected.length,
        s"Wrong number of steps obtained. ${reify(actual)}"
      )
    }.void
  }

  test("traces a single combinator") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("source")
    }
    val expected = List(
      step(labels = List(), e = OpenScope(label = "source")),
      step(labels = List("source"), e = Pull),
      step(labels = List("source"), e = Output(value = "Mao")),
      step(labels = List("source"), e = Pull),
      step(labels = List("source"), e = Done),
      step(labels = List(), e = CloseScope(label = "source")),
      step(labels = List(), e = Finished(errored = false))
    )

    assertSteps(actual, expected)
  }
  test("traces chunks") {
    val actual = Trace.simpleChunked[IO] { (_: Trace[IO]) ?=>
      Stream("Mao", "Popcorn")[IO]
        .trace("source")
    }
    // TODO: Scopes
    val expected = List(
      step(Nil, OpenScope("source")),
      step(List("source"), Pull),
      step(List("source"), OutputChunk(Chunk("Mao", "Popcorn"))),
      step(List("source"), Pull),
      step(List("source"), Done),
      step(Nil, CloseScope("source")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  test("traces multiple combinators") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("source")
        .map(_.toUpperCase)
        .trace("map")
    }
    val expected = List(
      step(Nil, OpenScope("map")),
      step(List("map"), Pull),
      step(List("map"), OpenScope("source")),
      step(List("source", "map"), Pull),
      step(List("source", "map"), Output("Mao")),
      step(List("map"), Output("MAO")),
      step(List("map"), Pull),
      step(List("source", "map"), Pull),
      step(List("source", "map"), Done),
      step(List("map"), CloseScope("source")),
      step(List("map"), Done),
      step(Nil, CloseScope("map")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  test("traces zipped streams") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("left")
        .zip(
          Stream("Popcorn")[IO]
            .trace("right")
        )
        .trace("zip")
    }
    val expected = List(
      step(Nil, OpenScope("zip")),
      step(List("zip"), Pull),
      step(List("zip"), OpenScope("left")),
      step(List("left", "zip"), Pull),
      step(List("left", "zip"), Output("Mao")),
      step(List("zip"), OpenScope("right")),
      step(List("right", "zip"), Pull),
      step(List("right", "zip"), Output("Popcorn")),
      step(List("zip"), Output("(Mao,Popcorn)")),
      step(List("zip"), Pull),
      step(List("left", "zip"), Pull),
      step(List("left", "zip"), Done),
      step(List("zip"), CloseScope("left")),
      step(List("zip"), CloseScope("right")),
      step(List("zip"), Done),
      step(Nil, CloseScope("zip")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  test("traces effect evaluation") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream
        .eval(IO("Mao").traceF())
        .trace("source")
    }
    val expected = List(
      step(Nil, OpenScope("source")),
      step(List("source"), Pull),
      step(List("source"), Eval("Mao")),
      step(List("source"), Output("Mao")),
      step(List("source"), Pull),
      step(List("source"), Done),
      step(Nil, CloseScope("source")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  test("traces raising errors") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("source")
        .evalTap(_ => IO.raiseError[String](Boom))
        .trace("eval")
    }
    val expected = List(
      step(labels = List(), e = OpenScope(label = "eval")),
      step(labels = List("eval"), e = Pull),
      step(labels = List("eval"), e = OpenScope(label = "source")),
      step(labels = List("source", "eval"), e = Pull),
      step(labels = List("source", "eval"), e = Output(value = "Mao")),
      step(labels = List("eval"), e = Error(value = "BOOM!")),
      step(labels = List(), e = CloseScope(label = "source")),
      step(labels = List(), e = CloseScope(label = "eval")),
      step(labels = List(), e = Finished(errored = true))
    )

    assertSteps(actual, expected)
  }

  test("traces handling errors") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("source")
        .evalTap(_ => IO.raiseError[String](Boom))
        .trace("eval")
        .handleErrorWith(_ => Stream.empty[IO].map(_.toString).trace("second"))
        .trace("handle")
    }
    val expected = List(
      step(Nil, OpenScope("handle")),
      step(List("handle"), Pull),
      step(List("handle"), OpenScope("eval")),
      step(List("eval", "handle"), Pull),
      step(List("eval", "handle"), OpenScope("source")),
      step(List("source", "eval", "handle"), Pull),
      step(List("source", "eval", "handle"), Output("Mao")),
      step(List("eval", "handle"), Error("BOOM!")),
      step(List("handle"), CloseScope("source")),
      step(List("handle"), CloseScope("eval")),
      step(List("handle"), OpenScope("second")),
      step(List("second", "handle"), Pull),
      step(List("second", "handle"), Done),
      step(List("handle"), CloseScope("second")),
      step(List("handle"), Done),
      step(Nil, CloseScope("handle")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  def bracket(suffix: String = "")(using t: Trace[IO]): Stream[IO, Unit] =
    Stream
      .bracket(IO(s"acquire$suffix").traceF().void)(_ =>
        IO(s"release$suffix").traceF().void
      )

  test("traces resources and errors") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      bracket()
        .trace("source")
        .evalTap(_ => IO.raiseError[String](Boom))
        .trace("eval")
    }
    val expected = List(
      step(Nil, OpenScope("eval")),
      step(List("eval"), Pull),
      step(List("eval"), OpenScope("source")),
      step(List("source", "eval"), Pull),
      step(List("source", "eval"), Eval("acquire")),
      step(List("source", "eval"), Output("()")),
      step(List("eval"), Error("BOOM!")),
      step(Nil, Eval("release")),
      step(Nil, CloseScope("source")),
      step(Nil, CloseScope("eval")),
      step(labels = Nil, Finished(errored = true))
    )
    assertSteps(actual, expected)
  }

  test("traces resources and error handling") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      bracket()
        .trace("source")
        .evalTap(_ => IO.raiseError[String](Boom))
        .trace("eval")
        .handleErrorWith(_ => Stream.empty[IO].as(()).trace("second"))
        .trace("handle")
    }
    val expected = List(
      step(Nil, OpenScope("handle")),
      step(List("handle"), Pull),
      step(List("handle"), OpenScope("eval")),
      step(List("eval", "handle"), Pull),
      step(List("eval", "handle"), OpenScope("source")),
      step(List("source", "eval", "handle"), Pull),
      step(List("source", "eval", "handle"), Eval("acquire")),
      step(List("source", "eval", "handle"), Output("()")),
      step(List("eval", "handle"), Error("BOOM!")),
      step(List("handle"), Eval("release")),
      step(List("handle"), CloseScope("source")),
      step(List("handle"), CloseScope("eval")),
      step(List("handle"), OpenScope("second")),
      step(List("second", "handle"), Pull),
      step(List("second", "handle"), Done),
      step(List("handle"), CloseScope("second")),
      step(List("handle"), Done),
      step(Nil, CloseScope("handle")),
      step(labels = Nil, Finished(errored = false))
    )
    assertSteps(actual, expected)
  }

  test("scope: error in parent") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      bracket("Left")
        .trace("left")
        .zip(
          bracket("Right")
            .trace("right")
        )
        .evalTap(_ => IO.raiseError[String](Boom))
        .trace("eval")
    }
    val expected = List(
      step(Nil, OpenScope("eval")),
      step(List("eval"), Pull),
      step(List("eval"), OpenScope("left")),
      step(List("left", "eval"), Pull),
      step(List("left", "eval"), Eval("acquireLeft")),
      step(List("left", "eval"), Output("()")),
      step(List("eval"), OpenScope("right")),
      step(List("right", "eval"), Pull),
      step(List("right", "eval"), Eval("acquireRight")),
      step(List("right", "eval"), Output("()")),
      step(List("eval"), Error("BOOM!")),
      step(Nil, Eval("releaseRight")),
      step(Nil, CloseScope("right")),
      step(Nil, Eval("releaseLeft")),
      step(Nil, CloseScope("left")),
      step(Nil, CloseScope("eval")),
      step(labels = Nil, Finished(errored = true))
    )
    assertSteps(actual, expected)
  }

  test("scope: error in child") {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      bracket("Left")
        .trace("left")
        .zip(
          bracket("Right")
            .evalTap(_ => IO.raiseError[String](Boom))
            .trace("right")
        )
        .trace("zip")
    }
    val expected = List(
      step(Nil, OpenScope("zip")),
      step(List("zip"), Pull),
      step(List("zip"), OpenScope("left")),
      step(List("left", "zip"), Pull),
      step(List("left", "zip"), Eval("acquireLeft")),
      step(List("left", "zip"), Output("()")),
      step(List("zip"), OpenScope("right")),
      step(List("right", "zip"), Pull),
      step(List("right", "zip"), Eval("acquireRight")),
      step(List("right", "zip"), Error("BOOM!")),
      step(List("zip"), Eval("releaseRight")),
      step(List("zip"), CloseScope("right")),
      step(List("zip"), Eval("releaseLeft")),
      step(List("zip"), CloseScope("left")),
      step(Nil, CloseScope("zip")),
      step(labels = Nil, Finished(errored = true))
    )
    assertSteps(actual, expected)
  }

  test("traces merged streams".ignored) {
    val actual = Trace.simple[IO] { (_: Trace[IO]) ?=>
      Stream("Mao")[IO]
        .trace("left", branch = "left")
        .fork("root", "left")
        .merge(
          Stream("Popcorn")[IO]
            .trace("right", branch = "right")
            .fork("root", "right")
        )
        .trace("merge")
    }
    // FIXME: There is a bug in the test or code.
    val expected = List(
      step(labels = List(), e = OpenScope(label = "merge")),
      step(labels = List("merge"), e = Pull),
      step(labels = List("merge"), e = OpenScope(label = "left")),
      step(labels = List("left", "merge"), e = Pull),
      step(labels = List("left", "merge"), e = OpenScope(label = "right")),
      step(labels = List("left", "merge"), e = Output(value = "Mao")),
      step(labels = List("right", "left", "merge"), e = Pull),
      step(
        labels = List("right", "left", "merge"),
        e = Output(value = "Popcorn")
      ),
      step(labels = List("merge"), e = Output(value = "Mao")),
      step(labels = List("merge"), e = Pull),
      step(labels = List("left", "merge"), e = Pull),
      step(labels = List("left", "merge"), e = Done),
      step(labels = List("merge"), e = CloseScope(label = "left")),
      step(labels = List("merge"), e = Output(value = "Popcorn")),
      step(labels = List("merge"), e = Pull),
      step(labels = List("right", "merge"), e = Pull),
      step(labels = List("right", "merge"), e = Done),
      step(labels = List("merge"), e = CloseScope(label = "right")),
      step(labels = List("merge"), e = Done),
      step(labels = List(), e = CloseScope(label = "merge")),
      step(labels = List(), e = Finished(errored = false))
    )
    assertSteps(actual, expected)
  }
}
